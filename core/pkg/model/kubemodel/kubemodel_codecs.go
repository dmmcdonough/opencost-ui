////////////////////////////////////////////////////////////////////////////////
//
//                             DO NOT MODIFY
//
//                          ┻━┻ ︵ヽ(`Д´)ﾉ︵ ┻━┻
//
//
//            This source file was automatically generated by bingen.
//
////////////////////////////////////////////////////////////////////////////////

package kubemodel

import (
	"fmt"
	util "github.com/opencost/opencost/core/pkg/util"
	"reflect"
	"strings"
	"sync"
	"time"
)

const (
	// GeneratorPackageName is the package the generator is targetting
	GeneratorPackageName string = "kubemodel"
)

// BinaryTags represent the formatting tag used for specific optimization features
const (
	// BinaryTagStringTable is written and/or read prior to the existence of a string
	// table (where each index is encoded as a string entry in the resource
	BinaryTagStringTable string = "BGST"
)

const (
	// DefaultCodecVersion is used for any resources listed in the Default version set
	DefaultCodecVersion uint8 = 1
)

//--------------------------------------------------------------------------
//  Type Map
//--------------------------------------------------------------------------

// Generated type map for resolving interface implementations to
// to concrete types
var typeMap map[string]reflect.Type = map[string]reflect.Type{
	"Cluster":                 reflect.TypeOf((*Cluster)(nil)).Elem(),
	"Diagnostic":              reflect.TypeOf((*Diagnostic)(nil)).Elem(),
	"KubeModelSet":            reflect.TypeOf((*KubeModelSet)(nil)).Elem(),
	"Metadata":                reflect.TypeOf((*Metadata)(nil)).Elem(),
	"Namespace":               reflect.TypeOf((*Namespace)(nil)).Elem(),
	"ResourceQuantity":        reflect.TypeOf((*ResourceQuantity)(nil)).Elem(),
	"ResourceQuota":           reflect.TypeOf((*ResourceQuota)(nil)).Elem(),
	"ResourceQuotaSpec":       reflect.TypeOf((*ResourceQuotaSpec)(nil)).Elem(),
	"ResourceQuotaSpecHard":   reflect.TypeOf((*ResourceQuotaSpecHard)(nil)).Elem(),
	"ResourceQuotaStatus":     reflect.TypeOf((*ResourceQuotaStatus)(nil)).Elem(),
	"ResourceQuotaStatusUsed": reflect.TypeOf((*ResourceQuotaStatusUsed)(nil)).Elem(),
	"Window":                  reflect.TypeOf((*Window)(nil)).Elem(),
}

//--------------------------------------------------------------------------
//  Type Helpers
//--------------------------------------------------------------------------

// isBinaryTag returns true when the first bytes in the provided binary matches the tag
func isBinaryTag(data []byte, tag string) bool {
	return string(data[:len(tag)]) == tag
}

// appendBytes combines a and b into a new byte array
func appendBytes(a []byte, b []byte) []byte {
	al := len(a)
	bl := len(b)
	tl := al + bl

	// allocate a new byte array for the combined
	// use native copy for speedy byte copying
	result := make([]byte, tl, tl)
	copy(result, a)
	copy(result[al:], b)

	return result
}

// typeToString determines the basic properties of the type, the qualifier, package path, and
// type name, and returns the qualified type
func typeToString(f interface{}) string {
	qual := ""
	t := reflect.TypeOf(f)
	if t.Kind() == reflect.Ptr {
		t = t.Elem()
		qual = "*"
	}

	return fmt.Sprintf("%s%s.%s", qual, t.PkgPath(), t.Name())
}

// resolveType uses the name of a type and returns the package, base type name, and whether
// or not it's a pointer.
func resolveType(t string) (pkg string, name string, isPtr bool) {
	isPtr = t[:1] == "*"
	if isPtr {
		t = t[1:]
	}

	slashIndex := strings.LastIndex(t, "/")
	if slashIndex >= 0 {
		t = t[slashIndex+1:]
	}
	parts := strings.Split(t, ".")
	if parts[0] == GeneratorPackageName {
		parts[0] = ""
	}

	pkg = parts[0]
	name = parts[1]
	return
}

//--------------------------------------------------------------------------
//  StringTable
//--------------------------------------------------------------------------

// StringTable maps strings to specific indices for encoding
type StringTable struct {
	l       *sync.Mutex
	indices map[string]int
	next    int
}

// NewStringTable Creates a new StringTable instance with provided contents
func NewStringTable(contents ...string) *StringTable {
	st := &StringTable{
		l:       new(sync.Mutex),
		indices: make(map[string]int),
		next:    len(contents),
	}

	for i, entry := range contents {
		st.indices[entry] = i
	}

	return st
}

// AddOrGet atomically retrieves a string entry's index if it exist. Otherwise, it will
// add the entry and return the index.
func (st *StringTable) AddOrGet(s string) int {
	st.l.Lock()
	defer st.l.Unlock()

	if ind, ok := st.indices[s]; ok {
		return ind
	}

	current := st.next
	st.next++

	st.indices[s] = current
	return current
}

// ToSlice Converts the contents to a string array for encoding.
func (st *StringTable) ToSlice() []string {
	st.l.Lock()
	defer st.l.Unlock()

	if st.next == 0 {
		return []string{}
	}

	sl := make([]string, st.next, st.next)
	for s, i := range st.indices {
		sl[i] = s
	}
	return sl
}

// ToBytes Converts the contents to a binary encoded representation
func (st *StringTable) ToBytes() []byte {
	buff := util.NewBuffer()
	buff.WriteBytes([]byte(BinaryTagStringTable)) // bingen table header

	strs := st.ToSlice()

	buff.WriteInt(len(strs)) // table length
	for _, s := range strs {
		buff.WriteString(s)
	}

	return buff.Bytes()
}

//--------------------------------------------------------------------------
//  Codec Context
//--------------------------------------------------------------------------

// EncodingContext is a context object passed to the encoders to ensure reuse of buffer
// and table data
type EncodingContext struct {
	Buffer *util.Buffer
	Table  *StringTable
}

// IsStringTable returns true if the table is available
func (ec *EncodingContext) IsStringTable() bool {
	return ec.Table != nil
}

// DecodingContext is a context object passed to the decoders to ensure parent objects
// reuse as much data as possible
type DecodingContext struct {
	Buffer *util.Buffer
	Table  []string
}

// IsStringTable returns true if the table is available
func (dc *DecodingContext) IsStringTable() bool {
	return len(dc.Table) > 0
}

//--------------------------------------------------------------------------
//  Binary Codec
//--------------------------------------------------------------------------

// BinEncoder is an encoding interface which defines a context based marshal contract.
type BinEncoder interface {
	MarshalBinaryWithContext(*EncodingContext) error
}

// BinDecoder is a decoding interface which defines a context based unmarshal contract.
type BinDecoder interface {
	UnmarshalBinaryWithContext(*DecodingContext) error
}

//--------------------------------------------------------------------------
//  Cluster
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Cluster instance
// into a byte array
func (target *Cluster) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Cluster instance
// into a byte array leveraging a predefined context.
func (target *Cluster) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.UID)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.UID) // write string
	}
	// --- [begin][write][alias](Provider) ---
	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(string(target.Provider))
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(string(target.Provider)) // write string
	}
	// --- [end][write][alias](Provider) ---

	if ctx.IsStringTable() {
		c := ctx.Table.AddOrGet(target.Account)
		buff.WriteInt(c) // write table index
	} else {
		buff.WriteString(target.Account) // write string
	}
	if ctx.IsStringTable() {
		d := ctx.Table.AddOrGet(target.Name)
		buff.WriteInt(d) // write table index
	} else {
		buff.WriteString(target.Name) // write string
	}
	// --- [begin][write][reference](time.Time) ---
	e, errA := target.Start.MarshalBinary()
	if errA != nil {
		return errA
	}
	buff.WriteInt(len(e))
	buff.WriteBytes(e)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	f, errB := target.End.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(f))
	buff.WriteBytes(f)
	// --- [end][write][reference](time.Time) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Cluster type
func (target *Cluster) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Cluster type
func (target *Cluster) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Cluster. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	// field version check
	if uint8(1) <= version {
		var b string
		if ctx.IsStringTable() {
			c := buff.ReadInt() // read string index
			b = ctx.Table[c]
		} else {
			b = buff.ReadString() // read string
		}
		a := b
		target.UID = a

	} else {
		target.UID = "" // default
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][alias](Provider) ---
		var d string
		var f string
		if ctx.IsStringTable() {
			g := buff.ReadInt() // read string index
			f = ctx.Table[g]
		} else {
			f = buff.ReadString() // read string
		}
		e := f
		d = e

		target.Provider = Provider(d)
		// --- [end][read][alias](Provider) ---

	} else {
	}

	// field version check
	if uint8(1) <= version {
		var k string
		if ctx.IsStringTable() {
			l := buff.ReadInt() // read string index
			k = ctx.Table[l]
		} else {
			k = buff.ReadString() // read string
		}
		h := k
		target.Account = h

	} else {
		target.Account = "" // default
	}

	// field version check
	if uint8(1) <= version {
		var n string
		if ctx.IsStringTable() {
			o := buff.ReadInt() // read string index
			n = ctx.Table[o]
		} else {
			n = buff.ReadString() // read string
		}
		m := n
		target.Name = m

	} else {
		target.Name = "" // default
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][reference](time.Time) ---
		p := &time.Time{}
		q := buff.ReadInt()    // byte array length
		r := buff.ReadBytes(q) // byte array
		errA := p.UnmarshalBinary(r)
		if errA != nil {
			return errA
		}
		target.Start = *p
		// --- [end][read][reference](time.Time) ---

	} else {
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][reference](time.Time) ---
		s := &time.Time{}
		t := buff.ReadInt()    // byte array length
		u := buff.ReadBytes(t) // byte array
		errB := s.UnmarshalBinary(u)
		if errB != nil {
			return errB
		}
		target.End = *s
		// --- [end][read][reference](time.Time) ---

	} else {
	}

	return nil
}

//--------------------------------------------------------------------------
//  Diagnostic
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Diagnostic instance
// into a byte array
func (target *Diagnostic) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Diagnostic instance
// into a byte array leveraging a predefined context.
func (target *Diagnostic) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	// --- [begin][write][reference](time.Time) ---
	a, errA := target.Timestamp.MarshalBinary()
	if errA != nil {
		return errA
	}
	buff.WriteInt(len(a))
	buff.WriteBytes(a)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][alias](DiagnosticLevel) ---
	buff.WriteInt(int(target.Level)) // write int
	// --- [end][write][alias](DiagnosticLevel) ---

	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.Message)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.Message) // write string
	}
	if target.Details == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(target.Details)) // map length
		for v, z := range target.Details {
			if ctx.IsStringTable() {
				c := ctx.Table.AddOrGet(v)
				buff.WriteInt(c) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				d := ctx.Table.AddOrGet(z)
				buff.WriteInt(d) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Diagnostic type
func (target *Diagnostic) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Diagnostic type
func (target *Diagnostic) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Diagnostic. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][reference](time.Time) ---
		a := &time.Time{}
		b := buff.ReadInt()    // byte array length
		c := buff.ReadBytes(b) // byte array
		errA := a.UnmarshalBinary(c)
		if errA != nil {
			return errA
		}
		target.Timestamp = *a
		// --- [end][read][reference](time.Time) ---

	} else {
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][alias](DiagnosticLevel) ---
		var d int
		e := buff.ReadInt() // read int
		d = e

		target.Level = DiagnosticLevel(d)
		// --- [end][read][alias](DiagnosticLevel) ---

	} else {
	}

	// field version check
	if uint8(1) <= version {
		var g string
		if ctx.IsStringTable() {
			h := buff.ReadInt() // read string index
			g = ctx.Table[h]
		} else {
			g = buff.ReadString() // read string
		}
		f := g
		target.Message = f

	} else {
		target.Message = "" // default
	}

	// field version check
	if uint8(1) <= version {
		if buff.ReadUInt8() == uint8(0) {
			target.Details = nil
		} else {
			// --- [begin][read][map](map[string]string) ---
			l := buff.ReadInt() // map len
			k := make(map[string]string, l)
			for i := 0; i < l; i++ {
				var v string
				var n string
				if ctx.IsStringTable() {
					o := buff.ReadInt() // read string index
					n = ctx.Table[o]
				} else {
					n = buff.ReadString() // read string
				}
				m := n
				v = m

				var z string
				var q string
				if ctx.IsStringTable() {
					r := buff.ReadInt() // read string index
					q = ctx.Table[r]
				} else {
					q = buff.ReadString() // read string
				}
				p := q
				z = p

				k[v] = z
			}
			target.Details = k
			// --- [end][read][map](map[string]string) ---

		}
	} else {
		target.Details = nil

	}

	return nil
}

//--------------------------------------------------------------------------
//  KubeModelSet
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this KubeModelSet instance
// into a byte array
func (target *KubeModelSet) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  NewStringTable(),
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	sTableBytes := ctx.Table.ToBytes()
	merged := appendBytes(sTableBytes, encBytes)
	return merged, nil
}

// MarshalBinaryWithContext serializes the internal properties of this KubeModelSet instance
// into a byte array leveraging a predefined context.
func (target *KubeModelSet) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	if target.Metadata == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](Metadata) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Metadata.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](Metadata) ---

	}
	// --- [begin][write][struct](Window) ---
	buff.WriteInt(0) // [compatibility, unused]
	errB := target.Window.MarshalBinaryWithContext(ctx)
	if errB != nil {
		return errB
	}
	// --- [end][write][struct](Window) ---

	if target.Cluster == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](Cluster) ---
		buff.WriteInt(0) // [compatibility, unused]
		errC := target.Cluster.MarshalBinaryWithContext(ctx)
		if errC != nil {
			return errC
		}
		// --- [end][write][struct](Cluster) ---

	}
	if target.Namespaces == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]*Namespace) ---
		buff.WriteInt(len(target.Namespaces)) // map length
		for v, z := range target.Namespaces {
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(v)
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if z == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](Namespace) ---
				buff.WriteInt(0) // [compatibility, unused]
				errD := z.MarshalBinaryWithContext(ctx)
				if errD != nil {
					return errD
				}
				// --- [end][write][struct](Namespace) ---

			}
		}
		// --- [end][write][map](map[string]*Namespace) ---

	}
	if target.ResourceQuotas == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]*ResourceQuota) ---
		buff.WriteInt(len(target.ResourceQuotas)) // map length
		for vv, zz := range target.ResourceQuotas {
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(vv)
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(vv) // write string
			}
			if zz == nil {
				buff.WriteUInt8(uint8(0)) // write nil byte
			} else {
				buff.WriteUInt8(uint8(1)) // write non-nil byte

				// --- [begin][write][struct](ResourceQuota) ---
				buff.WriteInt(0) // [compatibility, unused]
				errE := zz.MarshalBinaryWithContext(ctx)
				if errE != nil {
					return errE
				}
				// --- [end][write][struct](ResourceQuota) ---

			}
		}
		// --- [end][write][map](map[string]*ResourceQuota) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the KubeModelSet type
func (target *KubeModelSet) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the KubeModelSet type
func (target *KubeModelSet) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling KubeModelSet. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	// field version check
	if uint8(1) <= version {
		if buff.ReadUInt8() == uint8(0) {
			target.Metadata = nil
		} else {
			// --- [begin][read][struct](Metadata) ---
			a := &Metadata{}
			buff.ReadInt() // [compatibility, unused]
			errA := a.UnmarshalBinaryWithContext(ctx)
			if errA != nil {
				return errA
			}
			target.Metadata = a
			// --- [end][read][struct](Metadata) ---

		}
	} else {
		target.Metadata = nil

	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][struct](Window) ---
		b := &Window{}
		buff.ReadInt() // [compatibility, unused]
		errB := b.UnmarshalBinaryWithContext(ctx)
		if errB != nil {
			return errB
		}
		target.Window = *b
		// --- [end][read][struct](Window) ---

	} else {
	}

	// field version check
	if uint8(1) <= version {
		if buff.ReadUInt8() == uint8(0) {
			target.Cluster = nil
		} else {
			// --- [begin][read][struct](Cluster) ---
			c := &Cluster{}
			buff.ReadInt() // [compatibility, unused]
			errC := c.UnmarshalBinaryWithContext(ctx)
			if errC != nil {
				return errC
			}
			target.Cluster = c
			// --- [end][read][struct](Cluster) ---

		}
	} else {
		target.Cluster = nil

	}

	// field version check
	if uint8(1) <= version {
		if buff.ReadUInt8() == uint8(0) {
			target.Namespaces = nil
		} else {
			// --- [begin][read][map](map[string]*Namespace) ---
			e := buff.ReadInt() // map len
			d := make(map[string]*Namespace, e)
			for i := 0; i < e; i++ {
				var v string
				var g string
				if ctx.IsStringTable() {
					h := buff.ReadInt() // read string index
					g = ctx.Table[h]
				} else {
					g = buff.ReadString() // read string
				}
				f := g
				v = f

				var z *Namespace
				if buff.ReadUInt8() == uint8(0) {
					z = nil
				} else {
					// --- [begin][read][struct](Namespace) ---
					k := &Namespace{}
					buff.ReadInt() // [compatibility, unused]
					errD := k.UnmarshalBinaryWithContext(ctx)
					if errD != nil {
						return errD
					}
					z = k
					// --- [end][read][struct](Namespace) ---

				}
				d[v] = z
			}
			target.Namespaces = d
			// --- [end][read][map](map[string]*Namespace) ---

		}
	} else {
		target.Namespaces = nil

	}

	// field version check
	if uint8(1) <= version {
		if buff.ReadUInt8() == uint8(0) {
			target.ResourceQuotas = nil
		} else {
			// --- [begin][read][map](map[string]*ResourceQuota) ---
			m := buff.ReadInt() // map len
			l := make(map[string]*ResourceQuota, m)
			for j := 0; j < m; j++ {
				var vv string
				var o string
				if ctx.IsStringTable() {
					p := buff.ReadInt() // read string index
					o = ctx.Table[p]
				} else {
					o = buff.ReadString() // read string
				}
				n := o
				vv = n

				var zz *ResourceQuota
				if buff.ReadUInt8() == uint8(0) {
					zz = nil
				} else {
					// --- [begin][read][struct](ResourceQuota) ---
					q := &ResourceQuota{}
					buff.ReadInt() // [compatibility, unused]
					errE := q.UnmarshalBinaryWithContext(ctx)
					if errE != nil {
						return errE
					}
					zz = q
					// --- [end][read][struct](ResourceQuota) ---

				}
				l[vv] = zz
			}
			target.ResourceQuotas = l
			// --- [end][read][map](map[string]*ResourceQuota) ---

		}
	} else {
		target.ResourceQuotas = nil

	}

	return nil
}

//--------------------------------------------------------------------------
//  Metadata
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Metadata instance
// into a byte array
func (target *Metadata) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Metadata instance
// into a byte array leveraging a predefined context.
func (target *Metadata) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	// --- [begin][write][reference](time.Time) ---
	a, errA := target.CreatedAt.MarshalBinary()
	if errA != nil {
		return errA
	}
	buff.WriteInt(len(a))
	buff.WriteBytes(a)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	b, errB := target.CompletedAt.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	buff.WriteInt(target.ObjectCount) // write int
	if target.Diagnostics == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][slice]([]Diagnostic) ---
		buff.WriteInt(len(target.Diagnostics)) // array length
		for i := 0; i < len(target.Diagnostics); i++ {
			// --- [begin][write][struct](Diagnostic) ---
			buff.WriteInt(0) // [compatibility, unused]
			errC := target.Diagnostics[i].MarshalBinaryWithContext(ctx)
			if errC != nil {
				return errC
			}
			// --- [end][write][struct](Diagnostic) ---

		}
		// --- [end][write][slice]([]Diagnostic) ---

	}
	// --- [begin][write][alias](DiagnosticLevel) ---
	buff.WriteInt(int(target.DiagnosticLevel)) // write int
	// --- [end][write][alias](DiagnosticLevel) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Metadata type
func (target *Metadata) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Metadata type
func (target *Metadata) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Metadata. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][reference](time.Time) ---
		a := &time.Time{}
		b := buff.ReadInt()    // byte array length
		c := buff.ReadBytes(b) // byte array
		errA := a.UnmarshalBinary(c)
		if errA != nil {
			return errA
		}
		target.CreatedAt = *a
		// --- [end][read][reference](time.Time) ---

	} else {
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][reference](time.Time) ---
		d := &time.Time{}
		e := buff.ReadInt()    // byte array length
		f := buff.ReadBytes(e) // byte array
		errB := d.UnmarshalBinary(f)
		if errB != nil {
			return errB
		}
		target.CompletedAt = *d
		// --- [end][read][reference](time.Time) ---

	} else {
	}

	// field version check
	if uint8(1) <= version {
		g := buff.ReadInt() // read int
		target.ObjectCount = g

	} else {
		target.ObjectCount = int(0) // default
	}

	// field version check
	if uint8(1) <= version {
		if buff.ReadUInt8() == uint8(0) {
			target.Diagnostics = nil
		} else {
			// --- [begin][read][slice]([]Diagnostic) ---
			k := buff.ReadInt() // array len
			h := make([]Diagnostic, k)
			for i := 0; i < k; i++ {
				// --- [begin][read][struct](Diagnostic) ---
				m := &Diagnostic{}
				buff.ReadInt() // [compatibility, unused]
				errC := m.UnmarshalBinaryWithContext(ctx)
				if errC != nil {
					return errC
				}
				l := *m
				// --- [end][read][struct](Diagnostic) ---

				h[i] = l
			}
			target.Diagnostics = h
			// --- [end][read][slice]([]Diagnostic) ---

		}
	} else {
		target.Diagnostics = nil

	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][alias](DiagnosticLevel) ---
		var n int
		o := buff.ReadInt() // read int
		n = o

		target.DiagnosticLevel = DiagnosticLevel(n)
		// --- [end][read][alias](DiagnosticLevel) ---

	} else {
	}

	return nil
}

//--------------------------------------------------------------------------
//  Namespace
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Namespace instance
// into a byte array
func (target *Namespace) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Namespace instance
// into a byte array leveraging a predefined context.
func (target *Namespace) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.UID)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.UID) // write string
	}
	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.ClusterUID)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.ClusterUID) // write string
	}
	if ctx.IsStringTable() {
		c := ctx.Table.AddOrGet(target.Name)
		buff.WriteInt(c) // write table index
	} else {
		buff.WriteString(target.Name) // write string
	}
	if target.Labels == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(target.Labels)) // map length
		for v, z := range target.Labels {
			if ctx.IsStringTable() {
				d := ctx.Table.AddOrGet(v)
				buff.WriteInt(d) // write table index
			} else {
				buff.WriteString(v) // write string
			}
			if ctx.IsStringTable() {
				e := ctx.Table.AddOrGet(z)
				buff.WriteInt(e) // write table index
			} else {
				buff.WriteString(z) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	if target.Annotations == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[string]string) ---
		buff.WriteInt(len(target.Annotations)) // map length
		for vv, zz := range target.Annotations {
			if ctx.IsStringTable() {
				f := ctx.Table.AddOrGet(vv)
				buff.WriteInt(f) // write table index
			} else {
				buff.WriteString(vv) // write string
			}
			if ctx.IsStringTable() {
				g := ctx.Table.AddOrGet(zz)
				buff.WriteInt(g) // write table index
			} else {
				buff.WriteString(zz) // write string
			}
		}
		// --- [end][write][map](map[string]string) ---

	}
	// --- [begin][write][reference](time.Time) ---
	h, errA := target.Start.MarshalBinary()
	if errA != nil {
		return errA
	}
	buff.WriteInt(len(h))
	buff.WriteBytes(h)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	k, errB := target.End.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(k))
	buff.WriteBytes(k)
	// --- [end][write][reference](time.Time) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Namespace type
func (target *Namespace) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Namespace type
func (target *Namespace) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Namespace. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	// field version check
	if uint8(1) <= version {
		var b string
		if ctx.IsStringTable() {
			c := buff.ReadInt() // read string index
			b = ctx.Table[c]
		} else {
			b = buff.ReadString() // read string
		}
		a := b
		target.UID = a

	} else {
		target.UID = "" // default
	}

	// field version check
	if uint8(1) <= version {
		var e string
		if ctx.IsStringTable() {
			f := buff.ReadInt() // read string index
			e = ctx.Table[f]
		} else {
			e = buff.ReadString() // read string
		}
		d := e
		target.ClusterUID = d

	} else {
		target.ClusterUID = "" // default
	}

	// field version check
	if uint8(1) <= version {
		var h string
		if ctx.IsStringTable() {
			k := buff.ReadInt() // read string index
			h = ctx.Table[k]
		} else {
			h = buff.ReadString() // read string
		}
		g := h
		target.Name = g

	} else {
		target.Name = "" // default
	}

	// field version check
	if uint8(1) <= version {
		if buff.ReadUInt8() == uint8(0) {
			target.Labels = nil
		} else {
			// --- [begin][read][map](map[string]string) ---
			m := buff.ReadInt() // map len
			l := make(map[string]string, m)
			for i := 0; i < m; i++ {
				var v string
				var o string
				if ctx.IsStringTable() {
					p := buff.ReadInt() // read string index
					o = ctx.Table[p]
				} else {
					o = buff.ReadString() // read string
				}
				n := o
				v = n

				var z string
				var r string
				if ctx.IsStringTable() {
					s := buff.ReadInt() // read string index
					r = ctx.Table[s]
				} else {
					r = buff.ReadString() // read string
				}
				q := r
				z = q

				l[v] = z
			}
			target.Labels = l
			// --- [end][read][map](map[string]string) ---

		}
	} else {
		target.Labels = nil

	}

	// field version check
	if uint8(1) <= version {
		if buff.ReadUInt8() == uint8(0) {
			target.Annotations = nil
		} else {
			// --- [begin][read][map](map[string]string) ---
			u := buff.ReadInt() // map len
			t := make(map[string]string, u)
			for j := 0; j < u; j++ {
				var vv string
				var x string
				if ctx.IsStringTable() {
					y := buff.ReadInt() // read string index
					x = ctx.Table[y]
				} else {
					x = buff.ReadString() // read string
				}
				w := x
				vv = w

				var zz string
				var bb string
				if ctx.IsStringTable() {
					cc := buff.ReadInt() // read string index
					bb = ctx.Table[cc]
				} else {
					bb = buff.ReadString() // read string
				}
				aa := bb
				zz = aa

				t[vv] = zz
			}
			target.Annotations = t
			// --- [end][read][map](map[string]string) ---

		}
	} else {
		target.Annotations = nil

	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][reference](time.Time) ---
		dd := &time.Time{}
		ee := buff.ReadInt()     // byte array length
		ff := buff.ReadBytes(ee) // byte array
		errA := dd.UnmarshalBinary(ff)
		if errA != nil {
			return errA
		}
		target.Start = *dd
		// --- [end][read][reference](time.Time) ---

	} else {
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][reference](time.Time) ---
		gg := &time.Time{}
		hh := buff.ReadInt()     // byte array length
		kk := buff.ReadBytes(hh) // byte array
		errB := gg.UnmarshalBinary(kk)
		if errB != nil {
			return errB
		}
		target.End = *gg
		// --- [end][read][reference](time.Time) ---

	} else {
	}

	return nil
}

//--------------------------------------------------------------------------
//  ResourceQuantity
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this ResourceQuantity instance
// into a byte array
func (target *ResourceQuantity) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this ResourceQuantity instance
// into a byte array leveraging a predefined context.
func (target *ResourceQuantity) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	// --- [begin][write][alias](Resource) ---
	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(string(target.Resource))
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(string(target.Resource)) // write string
	}
	// --- [end][write][alias](Resource) ---

	// --- [begin][write][alias](Unit) ---
	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(string(target.Unit))
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(string(target.Unit)) // write string
	}
	// --- [end][write][alias](Unit) ---

	// --- [begin][write][alias](Stats) ---
	if map[StatType]float64(target.Values) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[StatType]float64) ---
		buff.WriteInt(len(map[StatType]float64(target.Values))) // map length
		for v, z := range map[StatType]float64(target.Values) {
			// --- [begin][write][alias](StatType) ---
			if ctx.IsStringTable() {
				c := ctx.Table.AddOrGet(string(v))
				buff.WriteInt(c) // write table index
			} else {
				buff.WriteString(string(v)) // write string
			}
			// --- [end][write][alias](StatType) ---

			buff.WriteFloat64(z) // write float64
		}
		// --- [end][write][map](map[StatType]float64) ---

	}
	// --- [end][write][alias](Stats) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the ResourceQuantity type
func (target *ResourceQuantity) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the ResourceQuantity type
func (target *ResourceQuantity) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling ResourceQuantity. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][alias](Resource) ---
		var a string
		var c string
		if ctx.IsStringTable() {
			d := buff.ReadInt() // read string index
			c = ctx.Table[d]
		} else {
			c = buff.ReadString() // read string
		}
		b := c
		a = b

		target.Resource = Resource(a)
		// --- [end][read][alias](Resource) ---

	} else {
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][alias](Unit) ---
		var e string
		var g string
		if ctx.IsStringTable() {
			h := buff.ReadInt() // read string index
			g = ctx.Table[h]
		} else {
			g = buff.ReadString() // read string
		}
		f := g
		e = f

		target.Unit = Unit(e)
		// --- [end][read][alias](Unit) ---

	} else {
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][alias](Stats) ---
		var k map[StatType]float64
		if buff.ReadUInt8() == uint8(0) {
			k = nil
		} else {
			// --- [begin][read][map](map[StatType]float64) ---
			m := buff.ReadInt() // map len
			l := make(map[StatType]float64, m)
			for i := 0; i < m; i++ {
				// --- [begin][read][alias](StatType) ---
				var n string
				var p string
				if ctx.IsStringTable() {
					q := buff.ReadInt() // read string index
					p = ctx.Table[q]
				} else {
					p = buff.ReadString() // read string
				}
				o := p
				n = o

				v := StatType(n)
				// --- [end][read][alias](StatType) ---

				var z float64
				r := buff.ReadFloat64() // read float64
				z = r

				l[v] = z
			}
			k = l
			// --- [end][read][map](map[StatType]float64) ---

		}
		target.Values = Stats(k)
		// --- [end][read][alias](Stats) ---

	} else {
	}

	return nil
}

//--------------------------------------------------------------------------
//  ResourceQuota
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this ResourceQuota instance
// into a byte array
func (target *ResourceQuota) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this ResourceQuota instance
// into a byte array leveraging a predefined context.
func (target *ResourceQuota) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	if ctx.IsStringTable() {
		a := ctx.Table.AddOrGet(target.UID)
		buff.WriteInt(a) // write table index
	} else {
		buff.WriteString(target.UID) // write string
	}
	if ctx.IsStringTable() {
		b := ctx.Table.AddOrGet(target.NamespaceUID)
		buff.WriteInt(b) // write table index
	} else {
		buff.WriteString(target.NamespaceUID) // write string
	}
	if ctx.IsStringTable() {
		c := ctx.Table.AddOrGet(target.Name)
		buff.WriteInt(c) // write table index
	} else {
		buff.WriteString(target.Name) // write string
	}
	if target.Spec == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](ResourceQuotaSpec) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Spec.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](ResourceQuotaSpec) ---

	}
	if target.Status == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](ResourceQuotaStatus) ---
		buff.WriteInt(0) // [compatibility, unused]
		errB := target.Status.MarshalBinaryWithContext(ctx)
		if errB != nil {
			return errB
		}
		// --- [end][write][struct](ResourceQuotaStatus) ---

	}
	// --- [begin][write][reference](time.Time) ---
	d, errC := target.Start.MarshalBinary()
	if errC != nil {
		return errC
	}
	buff.WriteInt(len(d))
	buff.WriteBytes(d)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	e, errD := target.End.MarshalBinary()
	if errD != nil {
		return errD
	}
	buff.WriteInt(len(e))
	buff.WriteBytes(e)
	// --- [end][write][reference](time.Time) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the ResourceQuota type
func (target *ResourceQuota) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the ResourceQuota type
func (target *ResourceQuota) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling ResourceQuota. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	// field version check
	if uint8(1) <= version {
		var b string
		if ctx.IsStringTable() {
			c := buff.ReadInt() // read string index
			b = ctx.Table[c]
		} else {
			b = buff.ReadString() // read string
		}
		a := b
		target.UID = a

	} else {
		target.UID = "" // default
	}

	// field version check
	if uint8(1) <= version {
		var e string
		if ctx.IsStringTable() {
			f := buff.ReadInt() // read string index
			e = ctx.Table[f]
		} else {
			e = buff.ReadString() // read string
		}
		d := e
		target.NamespaceUID = d

	} else {
		target.NamespaceUID = "" // default
	}

	// field version check
	if uint8(1) <= version {
		var h string
		if ctx.IsStringTable() {
			k := buff.ReadInt() // read string index
			h = ctx.Table[k]
		} else {
			h = buff.ReadString() // read string
		}
		g := h
		target.Name = g

	} else {
		target.Name = "" // default
	}

	// field version check
	if uint8(1) <= version {
		if buff.ReadUInt8() == uint8(0) {
			target.Spec = nil
		} else {
			// --- [begin][read][struct](ResourceQuotaSpec) ---
			l := &ResourceQuotaSpec{}
			buff.ReadInt() // [compatibility, unused]
			errA := l.UnmarshalBinaryWithContext(ctx)
			if errA != nil {
				return errA
			}
			target.Spec = l
			// --- [end][read][struct](ResourceQuotaSpec) ---

		}
	} else {
		target.Spec = nil

	}

	// field version check
	if uint8(1) <= version {
		if buff.ReadUInt8() == uint8(0) {
			target.Status = nil
		} else {
			// --- [begin][read][struct](ResourceQuotaStatus) ---
			m := &ResourceQuotaStatus{}
			buff.ReadInt() // [compatibility, unused]
			errB := m.UnmarshalBinaryWithContext(ctx)
			if errB != nil {
				return errB
			}
			target.Status = m
			// --- [end][read][struct](ResourceQuotaStatus) ---

		}
	} else {
		target.Status = nil

	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][reference](time.Time) ---
		n := &time.Time{}
		o := buff.ReadInt()    // byte array length
		p := buff.ReadBytes(o) // byte array
		errC := n.UnmarshalBinary(p)
		if errC != nil {
			return errC
		}
		target.Start = *n
		// --- [end][read][reference](time.Time) ---

	} else {
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][reference](time.Time) ---
		q := &time.Time{}
		r := buff.ReadInt()    // byte array length
		s := buff.ReadBytes(r) // byte array
		errD := q.UnmarshalBinary(s)
		if errD != nil {
			return errD
		}
		target.End = *q
		// --- [end][read][reference](time.Time) ---

	} else {
	}

	return nil
}

//--------------------------------------------------------------------------
//  ResourceQuotaSpec
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this ResourceQuotaSpec instance
// into a byte array
func (target *ResourceQuotaSpec) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this ResourceQuotaSpec instance
// into a byte array leveraging a predefined context.
func (target *ResourceQuotaSpec) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	if target.Hard == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](ResourceQuotaSpecHard) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Hard.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](ResourceQuotaSpecHard) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the ResourceQuotaSpec type
func (target *ResourceQuotaSpec) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the ResourceQuotaSpec type
func (target *ResourceQuotaSpec) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling ResourceQuotaSpec. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	// field version check
	if uint8(1) <= version {
		if buff.ReadUInt8() == uint8(0) {
			target.Hard = nil
		} else {
			// --- [begin][read][struct](ResourceQuotaSpecHard) ---
			a := &ResourceQuotaSpecHard{}
			buff.ReadInt() // [compatibility, unused]
			errA := a.UnmarshalBinaryWithContext(ctx)
			if errA != nil {
				return errA
			}
			target.Hard = a
			// --- [end][read][struct](ResourceQuotaSpecHard) ---

		}
	} else {
		target.Hard = nil

	}

	return nil
}

//--------------------------------------------------------------------------
//  ResourceQuotaSpecHard
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this ResourceQuotaSpecHard instance
// into a byte array
func (target *ResourceQuotaSpecHard) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this ResourceQuotaSpecHard instance
// into a byte array leveraging a predefined context.
func (target *ResourceQuotaSpecHard) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	// --- [begin][write][alias](ResourceQuantities) ---
	if map[Resource]ResourceQuantity(target.Requests) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[Resource]ResourceQuantity) ---
		buff.WriteInt(len(map[Resource]ResourceQuantity(target.Requests))) // map length
		for v, z := range map[Resource]ResourceQuantity(target.Requests) {
			// --- [begin][write][alias](Resource) ---
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(string(v))
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(string(v)) // write string
			}
			// --- [end][write][alias](Resource) ---

			// --- [begin][write][struct](ResourceQuantity) ---
			buff.WriteInt(0) // [compatibility, unused]
			errA := z.MarshalBinaryWithContext(ctx)
			if errA != nil {
				return errA
			}
			// --- [end][write][struct](ResourceQuantity) ---

		}
		// --- [end][write][map](map[Resource]ResourceQuantity) ---

	}
	// --- [end][write][alias](ResourceQuantities) ---

	// --- [begin][write][alias](ResourceQuantities) ---
	if map[Resource]ResourceQuantity(target.Limits) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[Resource]ResourceQuantity) ---
		buff.WriteInt(len(map[Resource]ResourceQuantity(target.Limits))) // map length
		for vv, zz := range map[Resource]ResourceQuantity(target.Limits) {
			// --- [begin][write][alias](Resource) ---
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(string(vv))
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(string(vv)) // write string
			}
			// --- [end][write][alias](Resource) ---

			// --- [begin][write][struct](ResourceQuantity) ---
			buff.WriteInt(0) // [compatibility, unused]
			errB := zz.MarshalBinaryWithContext(ctx)
			if errB != nil {
				return errB
			}
			// --- [end][write][struct](ResourceQuantity) ---

		}
		// --- [end][write][map](map[Resource]ResourceQuantity) ---

	}
	// --- [end][write][alias](ResourceQuantities) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the ResourceQuotaSpecHard type
func (target *ResourceQuotaSpecHard) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the ResourceQuotaSpecHard type
func (target *ResourceQuotaSpecHard) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling ResourceQuotaSpecHard. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][alias](ResourceQuantities) ---
		var a map[Resource]ResourceQuantity
		if buff.ReadUInt8() == uint8(0) {
			a = nil
		} else {
			// --- [begin][read][map](map[Resource]ResourceQuantity) ---
			c := buff.ReadInt() // map len
			b := make(map[Resource]ResourceQuantity, c)
			for i := 0; i < c; i++ {
				// --- [begin][read][alias](Resource) ---
				var d string
				var f string
				if ctx.IsStringTable() {
					g := buff.ReadInt() // read string index
					f = ctx.Table[g]
				} else {
					f = buff.ReadString() // read string
				}
				e := f
				d = e

				v := Resource(d)
				// --- [end][read][alias](Resource) ---

				// --- [begin][read][struct](ResourceQuantity) ---
				h := &ResourceQuantity{}
				buff.ReadInt() // [compatibility, unused]
				errA := h.UnmarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				z := *h
				// --- [end][read][struct](ResourceQuantity) ---

				b[v] = z
			}
			a = b
			// --- [end][read][map](map[Resource]ResourceQuantity) ---

		}
		target.Requests = ResourceQuantities(a)
		// --- [end][read][alias](ResourceQuantities) ---

	} else {
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][alias](ResourceQuantities) ---
		var k map[Resource]ResourceQuantity
		if buff.ReadUInt8() == uint8(0) {
			k = nil
		} else {
			// --- [begin][read][map](map[Resource]ResourceQuantity) ---
			m := buff.ReadInt() // map len
			l := make(map[Resource]ResourceQuantity, m)
			for j := 0; j < m; j++ {
				// --- [begin][read][alias](Resource) ---
				var n string
				var p string
				if ctx.IsStringTable() {
					q := buff.ReadInt() // read string index
					p = ctx.Table[q]
				} else {
					p = buff.ReadString() // read string
				}
				o := p
				n = o

				vv := Resource(n)
				// --- [end][read][alias](Resource) ---

				// --- [begin][read][struct](ResourceQuantity) ---
				r := &ResourceQuantity{}
				buff.ReadInt() // [compatibility, unused]
				errB := r.UnmarshalBinaryWithContext(ctx)
				if errB != nil {
					return errB
				}
				zz := *r
				// --- [end][read][struct](ResourceQuantity) ---

				l[vv] = zz
			}
			k = l
			// --- [end][read][map](map[Resource]ResourceQuantity) ---

		}
		target.Limits = ResourceQuantities(k)
		// --- [end][read][alias](ResourceQuantities) ---

	} else {
	}

	return nil
}

//--------------------------------------------------------------------------
//  ResourceQuotaStatus
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this ResourceQuotaStatus instance
// into a byte array
func (target *ResourceQuotaStatus) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this ResourceQuotaStatus instance
// into a byte array leveraging a predefined context.
func (target *ResourceQuotaStatus) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	if target.Used == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][struct](ResourceQuotaStatusUsed) ---
		buff.WriteInt(0) // [compatibility, unused]
		errA := target.Used.MarshalBinaryWithContext(ctx)
		if errA != nil {
			return errA
		}
		// --- [end][write][struct](ResourceQuotaStatusUsed) ---

	}
	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the ResourceQuotaStatus type
func (target *ResourceQuotaStatus) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the ResourceQuotaStatus type
func (target *ResourceQuotaStatus) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling ResourceQuotaStatus. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	// field version check
	if uint8(1) <= version {
		if buff.ReadUInt8() == uint8(0) {
			target.Used = nil
		} else {
			// --- [begin][read][struct](ResourceQuotaStatusUsed) ---
			a := &ResourceQuotaStatusUsed{}
			buff.ReadInt() // [compatibility, unused]
			errA := a.UnmarshalBinaryWithContext(ctx)
			if errA != nil {
				return errA
			}
			target.Used = a
			// --- [end][read][struct](ResourceQuotaStatusUsed) ---

		}
	} else {
		target.Used = nil

	}

	return nil
}

//--------------------------------------------------------------------------
//  ResourceQuotaStatusUsed
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this ResourceQuotaStatusUsed instance
// into a byte array
func (target *ResourceQuotaStatusUsed) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this ResourceQuotaStatusUsed instance
// into a byte array leveraging a predefined context.
func (target *ResourceQuotaStatusUsed) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	// --- [begin][write][alias](ResourceQuantities) ---
	if map[Resource]ResourceQuantity(target.Requests) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[Resource]ResourceQuantity) ---
		buff.WriteInt(len(map[Resource]ResourceQuantity(target.Requests))) // map length
		for v, z := range map[Resource]ResourceQuantity(target.Requests) {
			// --- [begin][write][alias](Resource) ---
			if ctx.IsStringTable() {
				a := ctx.Table.AddOrGet(string(v))
				buff.WriteInt(a) // write table index
			} else {
				buff.WriteString(string(v)) // write string
			}
			// --- [end][write][alias](Resource) ---

			// --- [begin][write][struct](ResourceQuantity) ---
			buff.WriteInt(0) // [compatibility, unused]
			errA := z.MarshalBinaryWithContext(ctx)
			if errA != nil {
				return errA
			}
			// --- [end][write][struct](ResourceQuantity) ---

		}
		// --- [end][write][map](map[Resource]ResourceQuantity) ---

	}
	// --- [end][write][alias](ResourceQuantities) ---

	// --- [begin][write][alias](ResourceQuantities) ---
	if map[Resource]ResourceQuantity(target.Limits) == nil {
		buff.WriteUInt8(uint8(0)) // write nil byte
	} else {
		buff.WriteUInt8(uint8(1)) // write non-nil byte

		// --- [begin][write][map](map[Resource]ResourceQuantity) ---
		buff.WriteInt(len(map[Resource]ResourceQuantity(target.Limits))) // map length
		for vv, zz := range map[Resource]ResourceQuantity(target.Limits) {
			// --- [begin][write][alias](Resource) ---
			if ctx.IsStringTable() {
				b := ctx.Table.AddOrGet(string(vv))
				buff.WriteInt(b) // write table index
			} else {
				buff.WriteString(string(vv)) // write string
			}
			// --- [end][write][alias](Resource) ---

			// --- [begin][write][struct](ResourceQuantity) ---
			buff.WriteInt(0) // [compatibility, unused]
			errB := zz.MarshalBinaryWithContext(ctx)
			if errB != nil {
				return errB
			}
			// --- [end][write][struct](ResourceQuantity) ---

		}
		// --- [end][write][map](map[Resource]ResourceQuantity) ---

	}
	// --- [end][write][alias](ResourceQuantities) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the ResourceQuotaStatusUsed type
func (target *ResourceQuotaStatusUsed) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the ResourceQuotaStatusUsed type
func (target *ResourceQuotaStatusUsed) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling ResourceQuotaStatusUsed. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][alias](ResourceQuantities) ---
		var a map[Resource]ResourceQuantity
		if buff.ReadUInt8() == uint8(0) {
			a = nil
		} else {
			// --- [begin][read][map](map[Resource]ResourceQuantity) ---
			c := buff.ReadInt() // map len
			b := make(map[Resource]ResourceQuantity, c)
			for i := 0; i < c; i++ {
				// --- [begin][read][alias](Resource) ---
				var d string
				var f string
				if ctx.IsStringTable() {
					g := buff.ReadInt() // read string index
					f = ctx.Table[g]
				} else {
					f = buff.ReadString() // read string
				}
				e := f
				d = e

				v := Resource(d)
				// --- [end][read][alias](Resource) ---

				// --- [begin][read][struct](ResourceQuantity) ---
				h := &ResourceQuantity{}
				buff.ReadInt() // [compatibility, unused]
				errA := h.UnmarshalBinaryWithContext(ctx)
				if errA != nil {
					return errA
				}
				z := *h
				// --- [end][read][struct](ResourceQuantity) ---

				b[v] = z
			}
			a = b
			// --- [end][read][map](map[Resource]ResourceQuantity) ---

		}
		target.Requests = ResourceQuantities(a)
		// --- [end][read][alias](ResourceQuantities) ---

	} else {
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][alias](ResourceQuantities) ---
		var k map[Resource]ResourceQuantity
		if buff.ReadUInt8() == uint8(0) {
			k = nil
		} else {
			// --- [begin][read][map](map[Resource]ResourceQuantity) ---
			m := buff.ReadInt() // map len
			l := make(map[Resource]ResourceQuantity, m)
			for j := 0; j < m; j++ {
				// --- [begin][read][alias](Resource) ---
				var n string
				var p string
				if ctx.IsStringTable() {
					q := buff.ReadInt() // read string index
					p = ctx.Table[q]
				} else {
					p = buff.ReadString() // read string
				}
				o := p
				n = o

				vv := Resource(n)
				// --- [end][read][alias](Resource) ---

				// --- [begin][read][struct](ResourceQuantity) ---
				r := &ResourceQuantity{}
				buff.ReadInt() // [compatibility, unused]
				errB := r.UnmarshalBinaryWithContext(ctx)
				if errB != nil {
					return errB
				}
				zz := *r
				// --- [end][read][struct](ResourceQuantity) ---

				l[vv] = zz
			}
			k = l
			// --- [end][read][map](map[Resource]ResourceQuantity) ---

		}
		target.Limits = ResourceQuantities(k)
		// --- [end][read][alias](ResourceQuantities) ---

	} else {
	}

	return nil
}

//--------------------------------------------------------------------------
//  Window
//--------------------------------------------------------------------------

// MarshalBinary serializes the internal properties of this Window instance
// into a byte array
func (target *Window) MarshalBinary() (data []byte, err error) {
	ctx := &EncodingContext{
		Buffer: util.NewBuffer(),
		Table:  nil,
	}

	e := target.MarshalBinaryWithContext(ctx)
	if e != nil {
		return nil, e
	}

	encBytes := ctx.Buffer.Bytes()
	return encBytes, nil
}

// MarshalBinaryWithContext serializes the internal properties of this Window instance
// into a byte array leveraging a predefined context.
func (target *Window) MarshalBinaryWithContext(ctx *EncodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	buff.WriteUInt8(DefaultCodecVersion) // version

	// --- [begin][write][reference](time.Time) ---
	a, errA := target.Start.MarshalBinary()
	if errA != nil {
		return errA
	}
	buff.WriteInt(len(a))
	buff.WriteBytes(a)
	// --- [end][write][reference](time.Time) ---

	// --- [begin][write][reference](time.Time) ---
	b, errB := target.End.MarshalBinary()
	if errB != nil {
		return errB
	}
	buff.WriteInt(len(b))
	buff.WriteBytes(b)
	// --- [end][write][reference](time.Time) ---

	return nil
}

// UnmarshalBinary uses the data passed byte array to set all the internal properties of
// the Window type
func (target *Window) UnmarshalBinary(data []byte) error {
	var table []string
	buff := util.NewBufferFromBytes(data)

	// string table header validation
	if isBinaryTag(data, BinaryTagStringTable) {
		buff.ReadBytes(len(BinaryTagStringTable)) // strip tag length
		tl := buff.ReadInt()                      // table length
		if tl > 0 {
			table = make([]string, tl, tl)
			for i := 0; i < tl; i++ {
				table[i] = buff.ReadString()
			}
		}
	}

	ctx := &DecodingContext{
		Buffer: buff,
		Table:  table,
	}

	err := target.UnmarshalBinaryWithContext(ctx)
	if err != nil {
		return err
	}

	return nil
}

// UnmarshalBinaryWithContext uses the context containing a string table and binary buffer to set all the internal properties of
// the Window type
func (target *Window) UnmarshalBinaryWithContext(ctx *DecodingContext) (err error) {
	// panics are recovered and propagated as errors
	defer func() {
		if r := recover(); r != nil {
			if e, ok := r.(error); ok {
				err = e
			} else if s, ok := r.(string); ok {
				err = fmt.Errorf("Unexpected panic: %s", s)
			} else {
				err = fmt.Errorf("Unexpected panic: %+v", r)
			}
		}
	}()

	buff := ctx.Buffer
	version := buff.ReadUInt8()

	if version > DefaultCodecVersion {
		return fmt.Errorf("Invalid Version Unmarshaling Window. Expected %d or less, got %d", DefaultCodecVersion, version)
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][reference](time.Time) ---
		a := &time.Time{}
		b := buff.ReadInt()    // byte array length
		c := buff.ReadBytes(b) // byte array
		errA := a.UnmarshalBinary(c)
		if errA != nil {
			return errA
		}
		target.Start = *a
		// --- [end][read][reference](time.Time) ---

	} else {
	}

	// field version check
	if uint8(1) <= version {
		// --- [begin][read][reference](time.Time) ---
		d := &time.Time{}
		e := buff.ReadInt()    // byte array length
		f := buff.ReadBytes(e) // byte array
		errB := d.UnmarshalBinary(f)
		if errB != nil {
			return errB
		}
		target.End = *d
		// --- [end][read][reference](time.Time) ---

	} else {
	}

	return nil
}
